for (i in 1:10) { print(i)}
X <- c("a","b","c","d")
for(y in X) print(y)
q()
install.packages(c("devtools", "jsonlite", "mime", "Rcpp", "xml2"))
clear()
x+y
add2 <- function(x,y){
x+y
}
add2(1+1)
add2(1,1)
add2(1,1000000000)
args(paste)
formals(paste)
q()
search()
install.packages("evaluate")
x <- Sys.Date()
x
x <- Sys.time()
x
p <- as.POSIXct(x)
p
p$sec
names(unclass(p))
p <- as.POSIXlt(x)
p$sec
d <- as.Date("1970-01-01")
p <- names(unclass(d))
p
quarters(as.Date("1970-01-01"))
months(as.Date("1970-01-01"))
weekdays(as.Date("1970-01-01"))
cube <- function(x,n) {
x^3
}
cube(3)
x <- 1 :10
if(x>5)
{
x<-0
}
x <- 0
x
x  <- 1:10
x
x <- 0
x
q()
n = c(2, 3, 5)
s = c("aa", "bb", "cc")
b = c(TRUE, FALSE, TRUE)
df = data.frame(n, s, b)
df
q()
?score
?solve
inverse <- function(m <- matrix()){
a <- m
solve(a)
a
}
inverse <- function(m <- matrix()){
inverse <- function(m = matrix()){
a <- m
b <- solve(a)
b
}
x <- matrix(1:9)
inverse(x)
x
x <- matrix(1:9, nrow = 3, ncol = 3)
x
inverse(x)
inverse(x)
det(x)
x <- matrix(c(1,0,5,2,1,6,3,4,0), nrow = 3, ncol = 3)
x
det(x)
inverse(x)
y <- matrix(c(4,3,3,2), nrow = 2, ncol = 2)
y
det(y)
inverse(y)
y <- matrix(c(42,7,6), nrow = 2, ncol = 2)
y <- matrix(c(4,2,7,6), nrow = 2, ncol = 2)
det(y)
inverse(y)
ls()
rm(list=ls())
setwd("~/RP/ProgrammingAssignment2")
ls
ls()
dir()
## Matrix inversion is usually a costly computation and there may be some benefit to caching the
## inverse of a matrix rather than compute it repeatedly.
## I have implemented a pair of functions that cache the inverse of a matrix.
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(m = matrix()) {
i <- NULL
set <- function(y){
m <<- y
i <<- NULL
}
get <- function(){
return(m)
}
setinverse <- function(inverse){
i <- inverse
}
getinverse <- function(){
return(i)
}
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then cacheSolve
## should retrieve the inverse from the cache.
cacheSolve <- function(m, ...) {
i <- m$getinverse()
if(!is.null(i)){
message("Please wait! Getting the cached data!")
return(i)
}
data <- m$get()
i <- solve(data,...)
m$setinverse(i)
return(i)
}
x <- matrix(c(1,0,5,2,1,6,3,4,0), nrow = 3, ncol = 3)
cacheSolve(x)
m1 <- makeCacheMatrix(x)
cacheSolve(m1)
cacheSolve(m1)
x <- matrix(c(4.2.7.6), nrow = 2, ncol = 2)
x <- matrix(c(4,2,7,6), nrow = 2, ncol = 2)
m1 <- makeCacheMatrix(x)
cacheSolve(m1)
x <- matrix(c(1,0,5,2,1,6,3,4,0), nrow = 3, ncol = 3)
cacheSolve(x)
m1 <- makeCacheMatrix(x)
cacheSolve(m1)
cacheSolve(m1)
cacheSolve(m1)
x <- matrix(c(1,0,5,2,1,6,3,4,0), nrow = 3, ncol = 3)
m <- makeCacheMatrix(x)
cacheSolve(m)
cacheSolve(m)
## Matrix inversion is usually a costly computation and there may be some benefit to caching the
## inverse of a matrix rather than compute it repeatedly.
## I have implemented a pair of functions that cache the inverse of a matrix.
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(m = matrix()) {
i <- NULL
set <- function(y){
m <<- y
i <<- NULL
}
get <- function(){
return(m)
}
setinverse <- function(inverse){
i <- inverse
}
getinverse <- function(){
return(i)
}
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then cacheSolve
## should retrieve the inverse from the cache.
cacheSolve <- function(m, ...) {
i <- m$getinverse()
if(!is.null(i)){
message("Please wait! Getting the cached data!")
i
}
data <- m$get()
i <- solve(data,...)
m$setinverse(i)
return(i)
}
x <- matrix(c(1,0,5,2,1,6,3,4,0), nrow = 3, ncol = 3)
m <- makeCacheMatrix(x)
cacheSolve(m)
cacheSolve(m)
## Matrix inversion is usually a costly computation and there may be some benefit to caching the
## inverse of a matrix rather than compute it repeatedly.
## I have implemented a pair of functions that cache the inverse of a matrix.
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(m = matrix()) {
i <- NULL
set <- function(y){
m <<- y
i <<- NULL
}
get <- function(){
return(m)
}
setinverse <- function(inverse){
i <- inverse
}
getinverse <- function(){
return(i)
}
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then cacheSolve
## should retrieve the inverse from the cache.
cacheSolve <- function(m, ...) {
i <- m$getinverse()
if(!is.null(i)){
message("Please wait! Getting the cached data!")
}
data <- m$get()
i <- solve(data,...)
m$setinverse(i)
return(i)
}
cacheSolve(m)
x <- matrix(c(1,0,5,2,1,6,3,4,0), nrow = 3, ncol = 3)
m <- makeCacheMatrix(x)
cacheSolve(m)
cacheSolve(m)
## Matrix inversion is usually a costly computation and there may be some benefit to caching the
## inverse of a matrix rather than compute it repeatedly.
## I have implemented a pair of functions that cache the inverse of a matrix.
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(m = matrix()) {
i <- NULL
set <- function(y){
m <<- y
i <<- NULL
}
get <- function(){
return(m)
}
setinverse <- function(inverse){
i <- inverse
}
getinverse <- function(){
return(i)
}
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then cacheSolve
## should retrieve the inverse from the cache.
cacheSolve <- function(m, ...) {
i <- m$getinverse()
if(!is.null(i)){
print("Please wait! Getting the cached data!")
return(i)
}
data <- m$get()
i <- solve(data)
m$setinverse(i)
return(i)
}
x <- matrix(c(1,0,5,2,1,6,3,4,0), nrow = 3, ncol = 3)
m <- makeCacheMatrix(x)
cacheSolve(m)
cacheSolve(m)
cacheSolve(x)
cacheSolve(x)
cacheSolve(m)
